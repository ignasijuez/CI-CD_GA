name: Pipeline

#events
on:
  push:
    branches: [ "main" ]
    #when someone pushes to branch main it triggers this workflow
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      REPO_URL:
        description: 'URL del repositorio'
        default: 'https://github.com/ignasijuez/CICD_GA.git'
        required: true
      BRANCH:
        description: 'Branch a clonar'
        default: 'main'
        required: true
      DOCKER_IMAGE:
        description: 'Nombre de la imagen de Docker'
        default: 'juezignasi/ga-app:latest'
        required: true

jobs:
  checkout: 
    runs-on: self-hosted
    steps:
      - name: Check hour and fail if inside time range
        run: |
          currentHour=$(date +%H)
          if [ "$currentHour" -ge 2 ] && [ "$currentHour" -lt 3 ]; then
            echo "El pipeline se termina porque no es la hora adecuada"
            exit 1
          fi

      # option 1
      - name: checkout
        uses: actions/checkout@v4 #predefined action from the marketplace
        with: 
          repository: ${{ inputs.REPO_URL }}
          ref: ${{ inputs.BRANCH }}

      - name: List workspace contents
        run: ls -R

      
      #- name: Capture Checkout Result
      #  run: |
      #    if [[ -z "${{ steps.checkout.outcome }}" ]]; then
      #      echo "CHECKOUT_STATUS=Success" >> $GITHUB_ENV
      #    else
      #      echo "CHECKOUT_STATUS=Failed" >> $GITHUB_ENV
      #      echo "CHECKOUT_ERROR=${{ steps.checkout.outcome }}" >> $GITHUB_ENV
      #      exit 1
      #    fi
        
      # option 2
      #- name: Checkout Repository
      #  id: checkout
      #  run: |
      #    CHECKOUT_OUTPUT=$(git clone ${{ inputs.REPO_URL }} -b ${{ inputs.BRANCH }} 2>&1) || { echo "$CHECKOUT_OUTPUT" > checkout_error.log; exit 1; }
      #  continue-on-error: true

      #- name: Capture Checkout Result
      #  if: always()
      #  run: |
      #    if [[ "${{ steps.checkout.outcome }}" == "success" ]]; then
      #      echo "CHECKOUT_STATUS=Success" >> $GITHUB_ENV
      #    else
      #      ERROR_MESSAGE=$(<checkout_error.log)
      #      echo "CHECKOUT_STATUS=Failed" >> $GITHUB_ENV
      #      echo "CHECKOUT_ERROR=${ERROR_MESSAGE}" >> $GITHUB_ENV
      #    fi

  setup:
    runs-on: self-hosted
    needs: checkout
    steps:
      # Cache Maven dependencies
      - name: Cache Maven packages
        uses: actions/cache@v2
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Set up JDK 17 & Maven
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'

  Prebuild-sonarScannerCloudScan:
    runs-on: self-hosted
    needs: setup
    steps:
      - name: Run SonarScanner
        env:
            SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
            SONAR_PROJECT_KEY: ignasijuez_github
            SONAR_ORGANIZATION: ignasijuez
        run: |
          sonar-scanner \
            -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
            -Dsonar.organization=${SONAR_ORGANIZATION} \
            -Dsonar.host.url=https://sonarcloud.io \
            -Dsonar.login=${SONAR_TOKEN} \
            -Dsonar.sources=src \
            -Dsonar.exclusions=**/*.java \
            -Dsonar.java.binaries=none \
            -Dsonar.qualitygate.wait=false


  Prebuild-Dependency-Analysis:
    runs-on: self-hosted
    needs: setup
    steps:
      - name: Run OWASP Dependency Check
        id: dependency_check
        run: |
          mkdir -p $GITHUB_WORKSPACE/dependency-check-report
          mvn org.owasp:dependency-check-maven:check \
              -Dformat=HTML \
              -DautoUpdate=false \
              -Dexcludes=com.h2database:h2 \
              -DoutputDirectory=dependency-check-report
          ls -R
        continue-on-error: true

      - name: Verify Dependency Check Report
        run: ls -R dependency-check-report

      - name: Upload Dependency-Check Report
        if: always() # Esto asegura que el informe se suba incluso si el análisis falla
        uses: actions/upload-artifact@v3
        with:
          name: dependency-check-report
          path: dependency-check-report/
      
      # Determine Dependency-Check Result
      - name: Check Dependency Validation Status
        run: |
          if [ "${{ steps.dependency_check.outcome }}" == "success" ]; then
            echo "Dependency validation marked as STABLE."
          else
            echo "Dependency validation marked as UNSTABLE."
          fi

  build:
      runs-on: self-hosted
      needs: [setup, Prebuild-sonarScannerCloudScan]
      outputs:
        BUILD_STATUS: ${{ steps.set_build_status.outputs.BUILD_STATUS }}
        BUILD_ERROR: ${{ steps.set_build_status.outputs.BUILD_ERROR }}
      steps:

      #original
      #- name: Build
      #  run: |
      #    echo 'Clean and package the application'
      #    mvn spring-javaformat:apply
      #    mvn clean package
  
      #- name: Build Application
      #  id: build_step
      #  run: |
      #    BUILD_OUTPUT=$(mvn spring-javaformat:apply && mvn clean package 2>&1) || { echo "$BUILD_OUTPUT" > build_error.log; exit 1; }
      #  continue-on-error: true

      #- name: Capture Build Result
      #  if: always()  # Se ejecuta siempre para capturar el estado del build
      #  run: |
      #    if [[ "${{ steps.build_step.outcome }}" == "success" ]]; then
      #      echo "BUILD_STATUS=Success" >> $GITHUB_ENV
      #    else
      #      ERROR_MESSAGE=$(<build_error.log)
      #      echo "BUILD_STATUS=Failed" >> $GITHUB_ENV
      #      echo "BUILD_ERROR=${ERROR_MESSAGE}" >> $GITHUB_ENV
      #      exit 1
      #    fi
      - name: Build Application
        id: build_step
        run: |
          BUILD_OUTPUT=$(mvn spring-javaformat:apply && mvn clean package 2>&1)
          echo "$BUILD_OUTPUT" > build_error.log
          echo "OUTPUTTTTTTTT: $BUILD_OUTPUT"
        continue-on-error: true

      - name: Capture Build Result
        id: set_build_status
        run: |
          if [[ "${{ steps.build_step.outcome }}" == "success" ]]; then
            echo "::set-output name=BUILD_STATUS::Success"
            echo "::set-output name=BUILD_ERROR::"
          else
            echo "::set-output name=BUILD_STATUS::Failed"
            BUILD_ERROR=$(<build_error.log)
            echo "::set-output name=BUILD_ERROR::$BUILD_ERROR"
          fi

  setup2:
    runs-on: self-hosted
    needs: setup
    steps:
      - name: home
        run: |
          echo $HOME
          ls -la

      - name: Setup Kubernetes
        uses: ./.github/actions/setup-k8s

      #- name: Set KUBECONFIG Environment Variable
      #  run: echo "KUBECONFIG=$HOME/.kube/config" >> $GITHUB_ENV

      #- name: Verify Kubernetes Context
      #  run: kubectl config get-contexts

      #- name: Set Minikube Context
      #  run: kubectl config use-context minikube

      #- name: Check2
      #  run: kubectl cluster-info

  #docker-login:
  #  runs-on: self-hosted
  #  needs: setup
  #  steps:
  #    - name: Log in to DockerHub
  #      run: echo "${{ secrets.DOCKERHUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin

  docker-login:
    needs: build
    uses: ./.github/workflows/reusable-docker-login.yml
    #with:
    #  DOCKER_IMAGE: "juezignasi/ga-app"
    #  IMAGE_TAG: "latest"
    secrets:
      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_PASSWORD: ${{ secrets.DOCKERHUB_PASSWORD }}

  #docker-build-push:
  #  runs-on: self-hosted
  #  needs: [build, docker-login]
  #  steps:
  #    - name: Build and push Docker image
  #      run: |
  #        docker build -t juezignasi/ga-app:latest .
  #        docker push juezignasi/ga-app:latest

  docker-build-push:
    runs-on: self-hosted
    needs: docker-login
    steps:
      #- name: Verify DOCKER_IMAGE value
      #  run: echo "DOCKER_IMAGE is set to ${{ inputs.DOCKER_IMAGE }}"

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: juezignasi/ga-app:latest

  deploy-mysql:
    runs-on: self-hosted
    needs: [setup2, docker-build-push]
    steps:
      - name: Deploy MySQL
        run: kubectl apply -f github-actions-k8s/mysql-deployment.yml

      - name: Get MySQL Pod Name
        run: |
          MYSQL_POD=$(kubectl get pod -l app=github-mysql-pod -o jsonpath="{.items[0].metadata.name}")
          echo "MYSQL_POD=$MYSQL_POD" >> $GITHUB_ENV

      - name: Wait for MySQL Pod to be Ready
        run: |
          while [[ $(kubectl get pod $MYSQL_POD -o jsonpath="{.status.phase}") != "Running" ]]; do
            echo "Waiting for MySQL pod to be ready..."
            sleep 5
          done
          echo "MySQL pod is ready!"
        env:
          MYSQL_POD: ${{ env.MYSQL_POD }}

      - name: Output MySQL Pod Name
        run: echo $MYSQL_POD
        env:
          MYSQL_POD: ${{ env.MYSQL_POD }}

      - name: Copy Init Scripts to MySQL Pod
        run: |
          kubectl cp ./src/main/resources/db/mysql_k8s/. $MYSQL_POD:/docker-entrypoint-initdb.d/
        env:
          MYSQL_POD: ${{ env.MYSQL_POD }}

      - name: Verify Init Scripts in MySQL Pod
        run: |
          kubectl exec $MYSQL_POD -- ls -la /docker-entrypoint-initdb.d/
        env:
          MYSQL_POD: ${{ env.MYSQL_POD }}

      - name: Execute Init Scripts in MySQL Pod
        run: |
          for script in $(kubectl exec $MYSQL_POD -- sh -c 'ls /docker-entrypoint-initdb.d/'); do
            echo "Executing $script in MySQL pod $MYSQL_POD"
            kubectl exec $MYSQL_POD -- sh -c "mysql -u root -e 'source /docker-entrypoint-initdb.d/$script'"
          done
        env:
          MYSQL_POD: ${{ env.MYSQL_POD }}

  deploy-app:
    runs-on: self-hosted
    needs: deploy-mysql
    steps:  
      - name: Deploy PetClinic
        run: kubectl apply -f github-actions-k8s/deployment.yml

      - name: Verify Pods
        run: kubectl get pods -o wide

  final-report:
    runs-on: self-hosted
    needs: [checkout, setup, build, setup2, docker-login, docker-build-push, deploy-mysql, deploy-app]
    if: always()
    steps:
      - name: Generate Final Report
        run: |
          report="{\"jobs\": []}"

          # Append Build Status
          build_status="${{ needs.build.outputs.BUILD_STATUS }}"
          build_error="${{ needs.build.outputs.BUILD_ERROR }}"
          report=$(echo "$report" | jq --arg name "build" --arg status "$build_status" --arg details "$build_error" '.jobs += [{"name": $name, "status": $status, "details": $details}]')

          echo "Final Report: $report"
          curl -X POST -H "Content-Type: application/json" -d "$report" https://httpbin.org/post

  #final-report:
  #  runs-on: self-hosted
  #  needs: deploy-app
  #  steps:
  #    - name: Send Build Report
  #      if: always()
  #      run: |
  #        if [[ "$BUILD_STATUS" == "Failed" ]]; then
  #          echo "Build failed with error: $BUILD_ERROR"
  #          # Envía el error detallado como parte del reporte
  #          curl -X POST https://httpbin.org/post \
  #          -H "Content-Type: application/json" \
  #          -d "{
  #            \"job\": \"Build\",
  #            \"status\": \"$BUILD_STATUS\",
  #            \"details\": \"$BUILD_ERROR\"
  #          }"
  #        else
  #          echo "Build succeeded"
  #          curl -X POST https://httpbin.org/post \
  #          -H "Content-Type: application/json" \
  #          -d "{
  #            \"job\": \"Build\",
  #            \"status\": \"$BUILD_STATUS\",
  #            \"details\": \"Build completed successfully\"
  #          }"
  #        fi

